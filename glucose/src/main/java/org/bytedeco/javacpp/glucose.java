// Targeted by JavaCPP version 1.2: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class glucose extends org.bytedeco.javacpp.presets.glucose {
    static { Loader.load(); }

// Parsed from mtl/Alloc.h

/*****************************************************************************************[Alloc.h]
Copyright (c) 2008-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/


// #ifndef Glucose_Alloc_h
// #define Glucose_Alloc_h

// #include "mtl/XAlloc.h"
// #include "mtl/Vec.h"

//=================================================================================================
// Simple Region-based memory allocator:

@Name("Glucose::RegionAllocator<uint32_t>") @NoOffset public static class RegionAllocatorPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RegionAllocatorPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public RegionAllocatorPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public RegionAllocatorPointer position(long position) {
        return (RegionAllocatorPointer)super.position(position);
    }

    // TODO: make this a class for better type-checking?
    /** enum Glucose::RegionAllocator<uint32_t>:: */
    public static final int Ref_Undef = 0;
    /** enum Glucose::RegionAllocator<uint32_t>:: */
    
public static native @MemberGetter int Unit_Size();
public static final int Unit_Size = Unit_Size();

    public RegionAllocatorPointer(@Cast("uint32_t") int start_cap/*=1024*1024*/) { super((Pointer)null); allocate(start_cap); }
    private native void allocate(@Cast("uint32_t") int start_cap/*=1024*1024*/);
    public RegionAllocatorPointer() { super((Pointer)null); allocate(); }
    private native void allocate();


    public native @Cast("uint32_t") int size();
    public native @Cast("uint32_t") int getCap();
    public native @Cast("uint32_t") int wasted();

    public native @Cast("Glucose::RegionAllocator<uint32_t>::Ref") long alloc(int size); 
    public native void free(int size);

    // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    public native @Cast("uint32_t*") @ByRef @Name("operator []") IntPointer get(@Cast("Glucose::RegionAllocator<uint32_t>::Ref") long r);

    public native @Cast("uint32_t*") IntPointer lea(@Cast("Glucose::RegionAllocator<uint32_t>::Ref") long r);
    public native @Cast("Glucose::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") IntPointer t);
    public native @Cast("Glucose::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") IntBuffer t);
    public native @Cast("Glucose::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") int[] t);

    public native void moveTo(@ByRef RegionAllocatorPointer to);

    public native void copyTo(@ByRef RegionAllocatorPointer to);



}







//=================================================================================================


// #endif


// Parsed from mtl/Vec.h

/*******************************************************************************************[Vec.h]
Copyright (c) 2003-2007, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/

// #ifndef Glucose_Vec_h
// #define Glucose_Vec_h

// #include <assert.h>
// #include <new>

// #include "mtl/IntTypes.h"
// #include "mtl/XAlloc.h"
// #include<string.h>

//=================================================================================================
// Automatically resizable arrays
//
// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)

@Name("Glucose::vec<Glucose::Lit>") @NoOffset public static class LitVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LitVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LitVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public LitVecPointer position(long position) {
        return (LitVecPointer)super.position(position);
    }
 // Yeah JNI doesn't work otherwise
    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") LitVecPointer put(@ByRef LitVecPointer other);
             public LitVecPointer(@ByRef LitVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef LitVecPointer other);
             
    // Helpers for calculating next capacity:
    public static native int imax(int x, int y);
    //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
    public static native void nextCap(@ByRef IntPointer cap);
    public static native void nextCap(@ByRef IntBuffer cap);
    public static native void nextCap(@ByRef int[] cap);
    // Constructors:
    public LitVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public LitVecPointer(int size) { super((Pointer)null); allocate(size); }
    private native void allocate(int size);
    public LitVecPointer(int size, @Const @ByRef Lit pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(int size, @Const @ByRef Lit pad);

    // Pointer to first element:
    public native @Name("operator Glucose::Lit*") Lit asLit();

    // Size operations:
    public native int size();
    public native void shrink(int nelems);
    public native void shrink_(int nelems);
    
    
    public native void growTo(int size);
    public native void growTo(int size, @Const @ByRef Lit pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    public native void push(@Const @ByRef Lit elem);
    public native void push_(@Const @ByRef Lit elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @ByRef Lit last();

    // Vector interface:
    public native @ByRef @Name("operator []") Lit get(int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef LitVecPointer copy);
    public native void moveTo(@ByRef LitVecPointer dest);
    public native void memCopyTo(@ByRef LitVecPointer copy);

}

@Name("Glucose::vec<Glucose::Var>") @NoOffset public static class VarVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VarVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VarVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public VarVecPointer position(long position) {
        return (VarVecPointer)super.position(position);
    }
 // Yeah JNI doesn't work otherwise
    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") VarVecPointer put(@ByRef VarVecPointer other);
             public VarVecPointer(@ByRef VarVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef VarVecPointer other);
             
    // Helpers for calculating next capacity:
    public static native int imax(int x, int y);
    //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
    public static native void nextCap(@ByRef IntPointer cap);
    public static native void nextCap(@ByRef IntBuffer cap);
    public static native void nextCap(@ByRef int[] cap);
    // Constructors:
    public VarVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public VarVecPointer(int size) { super((Pointer)null); allocate(size); }
    private native void allocate(int size);
    public VarVecPointer(int size, @Cast("const Glucose::Var") int pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(int size, @Cast("const Glucose::Var") int pad);

    // Pointer to first element:
    public native @Name("operator Glucose::Var*") IntPointer asIntPointer();

    // Size operations:
    public native int size();
    public native void shrink(int nelems);
    public native void shrink_(int nelems);
    
    
    public native void growTo(int size);
    public native void growTo(int size, @Cast("const Glucose::Var") int pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    public native void push(@Cast("const Glucose::Var") int elem);
    public native void push_(@Cast("const Glucose::Var") int elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @Cast("Glucose::Var*") @ByRef IntPointer last();

    // Vector interface:
    public native @Cast("Glucose::Var*") @ByRef @Name("operator []") IntPointer get(int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef VarVecPointer copy);
    public native void moveTo(@ByRef VarVecPointer dest);
    public native void memCopyTo(@ByRef VarVecPointer copy);

}

@Name("Glucose::vec<Glucose::lbool>") @NoOffset public static class LboolVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LboolVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LboolVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public LboolVecPointer position(long position) {
        return (LboolVecPointer)super.position(position);
    }
 // Yeah JNI doesn't work otherwise
    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") LboolVecPointer put(@ByRef LboolVecPointer other);
             public LboolVecPointer(@ByRef LboolVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef LboolVecPointer other);
             
    // Helpers for calculating next capacity:
    public static native int imax(int x, int y);
    //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
    public static native void nextCap(@ByRef IntPointer cap);
    public static native void nextCap(@ByRef IntBuffer cap);
    public static native void nextCap(@ByRef int[] cap);
    // Constructors:
    public LboolVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public LboolVecPointer(int size) { super((Pointer)null); allocate(size); }
    private native void allocate(int size);
    public LboolVecPointer(int size, @Const @ByRef lbool pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(int size, @Const @ByRef lbool pad);

    // Pointer to first element:
    public native @Name("operator Glucose::lbool*") lbool asLbool();

    // Size operations:
    public native int size();
    public native void shrink(int nelems);
    public native void shrink_(int nelems);
    
    
    public native void growTo(int size);
    public native void growTo(int size, @Const @ByRef lbool pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    public native void push(@Const @ByRef lbool elem);
    public native void push_(@Const @ByRef lbool elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @ByRef lbool last();

    // Vector interface:
    public native @ByRef @Name("operator []") lbool get(int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef LboolVecPointer copy);
    public native void moveTo(@ByRef LboolVecPointer dest);
    public native void memCopyTo(@ByRef LboolVecPointer copy);

}













//=================================================================================================


// #endif


// Parsed from mtl/Clone.h

// #ifndef Glucose_Clone_h
// #define Glucose_Clone_h

    @Name("Glucose::Clone") public static class ClonePointer extends Pointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public ClonePointer(Pointer p) { super(p); }
    
          public native ClonePointer clone();
    }


// #endif

// Parsed from core/SolverTypes.h

/***************************************************************************************[SolverTypes.h]
 Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                LRI  - Univ. Paris Sud, France (2009-2013)
                                Labri - Univ. Bordeaux, France
 <p>
 Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                Labri - Univ. Bordeaux, France
<p>
Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
is based on. (see below).
<p>
Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
without restriction, including the rights to use, copy, modify, merge, publish, distribute,
sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions:
<p>
- The above and below copyrights notices and this permission notice shall be included in all
copies or substantial portions of the Software;
- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
be used in any competitive event (sat competitions/evaluations) without the express permission of 
the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
using Glucose Parallel as an embedded SAT engine (single core or not).
<p>
<p>
--------------- Original Minisat Copyrights
<p>
Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/


// #ifndef Glucose_SolverTypes_h
// #define Glucose_SolverTypes_h

// #include <assert.h>
// #include <stdint.h>
// #include <pthread.h>

// #include "mtl/IntTypes.h"
// #include "mtl/Alg.h"
// #include "mtl/Vec.h"
// #include "mtl/Map.h"
// #include "mtl/Alloc.h"

//=================================================================================================
// Variables, literals, lifted booleans, clauses:


// NOTE! Variables are just integers. No abstraction here. They should be chosen from 0..N,
// so that they can be used as array indices.
public static final int var_Undef = (-1);


@Namespace("Glucose") public static class Lit extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Lit() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Lit(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Lit(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Lit position(long position) {
        return (Lit)super.position(position);
    }

    public native int x(); public native Lit x(int x);

    // Use this as a constructor:
    

    public native @Cast("bool") @Name("operator ==") boolean equals(@ByVal Lit p);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@ByVal Lit p);
    public native @Cast("bool") @Name("operator <") boolean lessThan(@ByVal Lit p); // '<' makes p, ~p adjacent in the ordering.
}


@Namespace("Glucose") public static native @ByVal Lit mkLit(@Cast("Glucose::Var") int var, @Cast("bool") boolean sign/*=false*/);
@Namespace("Glucose") public static native @ByVal Lit mkLit(@Cast("Glucose::Var") int var);
@Namespace("Glucose") public static native @ByVal @Name("operator ~") Lit not(@ByVal Lit p);
@Namespace("Glucose") public static native @ByVal @Name("operator ^") Lit xor(@ByVal Lit p, @Cast("bool") boolean b);
@Namespace("Glucose") public static native @Cast("bool") boolean sign(@ByVal Lit p);
@Namespace("Glucose") public static native int var(@ByVal Lit p);

// Mapping Literals to and from compact integers suitable for array indexing:
@Namespace("Glucose") public static native int toInt(@Cast("Glucose::Var") int v); 
@Namespace("Glucose") public static native int toInt(@ByVal Lit p); 
@Namespace("Glucose") public static native @ByVal Lit toLit(int i); 

//const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
//const Lit lit_Error = mkLit(var_Undef, true );  // }

@Namespace("Glucose") @MemberGetter public static native @Const @ByRef Lit lit_Undef();  // }- Useful special constants.
@Namespace("Glucose") @MemberGetter public static native @Const @ByRef Lit lit_Error();  // }


//=================================================================================================
// Lifted booleans:
//
// NOTE: this implementation is optimized for the case when comparisons between values are mostly
//       between one variable and one constant. Some care had to be taken to make sure that gcc 
//       does enough constant propagation to produce sensible code, and this appears to be somewhat
//       fragile unfortunately.

public static native @MemberGetter @ByVal lbool l_True();
public static final lbool l_True = l_True(); // gcc does not do constant propagation if these are real constants.
public static native @MemberGetter @ByVal lbool l_False();
public static final lbool l_False = l_False();
public static native @MemberGetter @ByVal lbool l_Undef();
public static final lbool l_Undef = l_Undef();

@Namespace("Glucose") @NoOffset public static class lbool extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public lbool(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public lbool(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public lbool position(long position) {
        return (lbool)super.position(position);
    }

    public lbool(@Cast("uint8_t") byte v) { super((Pointer)null); allocate(v); }
    private native void allocate(@Cast("uint8_t") byte v);

    public lbool() { super((Pointer)null); allocate(); }
    private native void allocate();
    public lbool(@Cast("bool") boolean x) { super((Pointer)null); allocate(x); }
    private native void allocate(@Cast("bool") boolean x);

    public native @Cast("bool") @Name("operator ==") boolean equals(@ByVal lbool b);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@ByVal lbool b);
    public native @ByVal @Name("operator ^") lbool xor(@Cast("bool") boolean b);

    public native @ByVal @Name("operator &&") lbool and(@ByVal lbool b);

    public native @ByVal @Name("operator ||") lbool or(@ByVal lbool b);

    
    
}
@Namespace("Glucose") public static native int toInt(@ByVal lbool l);
@Namespace("Glucose") public static native @ByVal lbool toLbool(int v);

//=================================================================================================
// Clause -- a simple class for representing a clause:

public static final int BITS_LBD = 13;
public static final int BITS_SIZEWITHOUTSEL = 19;
public static final int BITS_REALSIZE = 21;


//=================================================================================================
// ClauseAllocator -- a simple class for allocating memory for clauses:


@Namespace("Glucose") @MemberGetter public static native @Cast("const Glucose::CRef") long CRef_Undef();


//=================================================================================================
// OccLists -- a class for maintaining occurence lists with lazy deletion:








//=================================================================================================
// CMap -- a class for mapping clauses to values:


/*_________________________________________________________________________________________________
|
|  subsumes : (other : const Clause&)  ->  Lit
|  
|  Description:
|       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
|       by subsumption resolution.
|  
|    Result:
|       lit_Error  - No subsumption or simplification
|       lit_Undef  - Clause subsumes 'other'
|       p          - The literal p can be deleted from 'other'
|________________________________________________________________________________________________@*/



 
//=================================================================================================


 
// #endif


// Parsed from core/Solver.h

/***************************************************************************************[Solver.h]
 Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                LRI  - Univ. Paris Sud, France (2009-2013)
                                Labri - Univ. Bordeaux, France
 <p>
 Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                Labri - Univ. Bordeaux, France
<p>
Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
is based on. (see below).
<p>
Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
without restriction, including the rights to use, copy, modify, merge, publish, distribute,
sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions:
<p>
- The above and below copyrights notices and this permission notice shall be included in all
copies or substantial portions of the Software;
- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
be used in any competitive event (sat competitions/evaluations) without the express permission of 
the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
using Glucose Parallel as an embedded SAT engine (single core or not).
<p>
<p>
--------------- Original Minisat Copyrights
<p>
Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/

// #ifndef Glucose_Solver_h
// #define Glucose_Solver_h

// #include "mtl/Heap.h"
// #include "mtl/Alg.h"
// #include "utils/Options.h"
// #include "core/SolverTypes.h"
// #include "core/BoundedQueue.h"
// #include "core/Constants.h"
// #include "mtl/Clone.h"

//=================================================================================================
// Solver -- the main class:

@Namespace("Glucose") @NoOffset public static class Solver extends ClonePointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Solver(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Solver(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Solver position(long position) {
        return (Solver)super.position(position);
    }


    // Constructor/Destructor:
    //
    public Solver() { super((Pointer)null); allocate(); }
    private native void allocate();
    public Solver(@Const @ByRef Solver s) { super((Pointer)null); allocate(s); }
    private native void allocate(@Const @ByRef Solver s);
    
    /**
     * Clone function
     */
    public native ClonePointer clone();   

    // Problem specification:
    //
    public native @Cast("Glucose::Var") int newVar(@Cast("bool") boolean polarity/*=true*/, @Cast("bool") boolean dvar/*=true*/);
    public native @Cast("Glucose::Var") int newVar(); // Add a new variable with parameters specifying variable mode.
    public native @Cast("bool") boolean addClause(@Const @ByRef LitVecPointer ps);                     // Add a clause to the solver. 
    public native @Cast("bool") boolean addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
    public native @Cast("bool") boolean addClause(@ByVal Lit p);                                  // Add a unit clause to the solver. 
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q);                           // Add a binary clause to the solver. 
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);                    // Add a ternary clause to the solver. 
    public native @Cast("bool") boolean addClause_(      @ByRef LitVecPointer ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                // change the passed vector 'ps'.

    // Solving:
    //
    public native @Cast("bool") boolean simplify();                        // Removes already satisfied clauses.
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps); // Search for a model that respects a given set of assumptions.
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps); // Search for a model that respects a given set of assumptions (With resource constraints).
    public native @Cast("bool") boolean solve();                        // Search without assumptions.
    public native @Cast("bool") boolean solve(@ByVal Lit p);                   // Search for a model that respects a single assumption.
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q);            // Search for a model that respects two assumptions.
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);     // Search for a model that respects three assumptions.
    public native @Cast("bool") boolean okay();                  // FALSE means solver is in a conflicting state

       // Convenience versions of 'toDimacs()':
    public native void toDimacs(@Cast("FILE*") Pointer f, @Const @ByRef LitVecPointer assumps);            // Write CNF to file in DIMACS-format.
    public native void toDimacs(@Cast("const char*") BytePointer file, @Const @ByRef LitVecPointer assumps);
    public native void toDimacs(String file, @Const @ByRef LitVecPointer assumps);
    public native void toDimacs(@Cast("const char*") BytePointer file);
    public native void toDimacs(String file);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p);
    public native void toDimacs(String file, @ByVal Lit p);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p, @ByVal Lit q);
    public native void toDimacs(String file, @ByVal Lit p, @ByVal Lit q);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
    public native void toDimacs(String file, @ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
 
    // Display clauses and literals
    public native void printLit(@ByVal Lit l);
    public native void printClause(@Cast("Glucose::CRef") long c);
    public native void printInitialClause(@Cast("Glucose::CRef") long c);
    
    // Variable mode:
    // 
    public native void setPolarity(@Cast("Glucose::Var") int v, @Cast("bool") boolean b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
    public native void setDecisionVar(@Cast("Glucose::Var") int v, @Cast("bool") boolean b); // Declare if a variable should be eligible for selection in the decision heuristic.

    // Read state:
    //
    public native @ByVal lbool value(@Cast("Glucose::Var") int x);       // The current value of a variable.
    public native @ByVal lbool value(@ByVal Lit p);       // The current value of a literal.
    public native @ByVal lbool modelValue(@Cast("Glucose::Var") int x);       // The value of a variable in the last model. The last call to solve must have been satisfiable.
    public native @ByVal lbool modelValue(@ByVal Lit p);       // The value of a literal in the last model. The last call to solve must have been satisfiable.
    public native int nAssigns();       // The current number of assigned literals.
    public native int nClauses();       // The current number of original clauses.
    public native int nLearnts();       // The current number of learnt clauses.
    public native int nVars();       // The current number of variables.
    public native int nFreeVars();

    public native @Cast("char") byte valuePhase(@Cast("Glucose::Var") int v);

    // Incremental mode
    public native void setIncrementalMode();
    public native void initNbInitialVars(int nb);
    public native void printIncrementalStats();
    public native @Cast("bool") boolean isIncremental();
    // Resource contraints:
    //
    public native void setConfBudget(@Cast("int64_t") long x);
    public native void setPropBudget(@Cast("int64_t") long x);
    public native void budgetOff();
    public native void interrupt();          // Trigger a (potentially asynchronous) interruption of the solver.
    public native void clearInterrupt();     // Clear interrupt indicator flag.

    // Memory managment:
    //
    public native void garbageCollect();
    public native void checkGarbage(double gf);
    public native void checkGarbage();

    // Extra results: (read-only member variable)
    //
    public native @ByRef LboolVecPointer model(); public native Solver model(LboolVecPointer model);             // If problem is satisfiable, this vector contains the model (if any).
    public native @ByRef LitVecPointer conflict(); public native Solver conflict(LitVecPointer conflict);          // If problem is unsatisfiable (possibly under assumptions),
                                  // this vector represent the final conflict clause expressed in the assumptions.

    // Mode of operation:
    //
    public native int verbosity(); public native Solver verbosity(int verbosity);
    public native int verbEveryConflicts(); public native Solver verbEveryConflicts(int verbEveryConflicts);
    public native int showModel(); public native Solver showModel(int showModel);
    
    // Constants For restarts
    public native double K(); public native Solver K(double K);
    public native double R(); public native Solver R(double R);
    public native double sizeLBDQueue(); public native Solver sizeLBDQueue(double sizeLBDQueue);
    public native double sizeTrailQueue(); public native Solver sizeTrailQueue(double sizeTrailQueue);

    // Constants for reduce DB
    public native int firstReduceDB(); public native Solver firstReduceDB(int firstReduceDB);
    public native int incReduceDB(); public native Solver incReduceDB(int incReduceDB);
    public native int specialIncReduceDB(); public native Solver specialIncReduceDB(int specialIncReduceDB);
    public native @Cast("unsigned int") int lbLBDFrozenClause(); public native Solver lbLBDFrozenClause(int lbLBDFrozenClause);

    // Constant for reducing clause
    public native int lbSizeMinimizingClause(); public native Solver lbSizeMinimizingClause(int lbSizeMinimizingClause);
    public native @Cast("unsigned int") int lbLBDMinimizingClause(); public native Solver lbLBDMinimizingClause(int lbLBDMinimizingClause);

    // Constant for heuristic
    public native double var_decay(); public native Solver var_decay(double var_decay);
    public native double max_var_decay(); public native Solver max_var_decay(double max_var_decay);
    public native double clause_decay(); public native Solver clause_decay(double clause_decay);
    public native double random_var_freq(); public native Solver random_var_freq(double random_var_freq);
    public native double random_seed(); public native Solver random_seed(double random_seed);
    public native int ccmin_mode(); public native Solver ccmin_mode(int ccmin_mode);         // Controls conflict clause minimization (0=none, 1=basic, 2=deep).
    public native int phase_saving(); public native Solver phase_saving(int phase_saving);       // Controls the level of phase saving (0=none, 1=limited, 2=full).
    public native @Cast("bool") boolean rnd_pol(); public native Solver rnd_pol(boolean rnd_pol);            // Use random polarities for branching heuristics.
    public native @Cast("bool") boolean rnd_init_act(); public native Solver rnd_init_act(boolean rnd_init_act);       // Initialize variable activities with a small random value.
    
    // Constant for Memory managment
    public native double garbage_frac(); public native Solver garbage_frac(double garbage_frac);       // The fraction of wasted memory allowed before a garbage collection is triggered.

    // Certified UNSAT ( Thanks to Marijn Heule)
    public native @Cast("FILE*") Pointer certifiedOutput(); public native Solver certifiedOutput(Pointer certifiedOutput);
    public native @Cast("bool") boolean certifiedUNSAT(); public native Solver certifiedUNSAT(boolean certifiedUNSAT);

    // Panic mode. 
    // Save memory
    public native @Cast("uint32_t") int panicModeLastRemoved(); public native Solver panicModeLastRemoved(int panicModeLastRemoved);
    public native @Cast("uint32_t") int panicModeLastRemovedShared(); public native Solver panicModeLastRemovedShared(int panicModeLastRemovedShared);
    
    public native @Cast("bool") boolean useUnaryWatched(); public native Solver useUnaryWatched(boolean useUnaryWatched);            // Enable unary watched literals
    public native @Cast("bool") boolean promoteOneWatchedClause(); public native Solver promoteOneWatchedClause(boolean promoteOneWatchedClause);    // One watched clauses are promotted to two watched clauses if found empty
    
    // Functions useful for multithread solving
    // Useless in the sequential case 
    // Overide in ParallelSolver
    public native @Cast("bool") boolean parallelImportClauses(); // true if the empty clause was received
    public native void parallelImportUnaryClauses();
    public native void parallelExportUnaryClause(@ByVal Lit p);
    public native @Cast("bool") boolean parallelJobIsFinished();
    public native @Cast("bool") boolean panicModeIsEnabled();
    
    

    // Statistics: (read-only member variable)
    public native @Cast("uint64_t") long nbPromoted(); public native Solver nbPromoted(long nbPromoted);          // Number of clauses from unary to binary watch scheme
    public native @Cast("uint64_t") long originalClausesSeen(); public native Solver originalClausesSeen(long originalClausesSeen); // Number of original clauses seen
    public native @Cast("uint64_t") long sumDecisionLevels(); public native Solver sumDecisionLevels(long sumDecisionLevels);
    //
    public native @Cast("uint64_t") long nbRemovedClauses(); public native Solver nbRemovedClauses(long nbRemovedClauses);
    public native @Cast("uint64_t") long nbRemovedUnaryWatchedClauses(); public native Solver nbRemovedUnaryWatchedClauses(long nbRemovedUnaryWatchedClauses);
    public native @Cast("uint64_t") long nbReducedClauses(); public native Solver nbReducedClauses(long nbReducedClauses);
    public native @Cast("uint64_t") long nbDL2(); public native Solver nbDL2(long nbDL2);
    public native @Cast("uint64_t") long nbBin(); public native Solver nbBin(long nbBin);
    public native @Cast("uint64_t") long nbUn(); public native Solver nbUn(long nbUn);
    public native @Cast("uint64_t") long nbReduceDB(); public native Solver nbReduceDB(long nbReduceDB);
    public native @Cast("uint64_t") long solves(); public native Solver solves(long solves);
    public native @Cast("uint64_t") long starts(); public native Solver starts(long starts);
    public native @Cast("uint64_t") long decisions(); public native Solver decisions(long decisions);
    public native @Cast("uint64_t") long rnd_decisions(); public native Solver rnd_decisions(long rnd_decisions);
    public native @Cast("uint64_t") long propagations(); public native Solver propagations(long propagations);
    public native @Cast("uint64_t") long conflicts(); public native Solver conflicts(long conflicts);
    public native @Cast("uint64_t") long conflictsRestarts(); public native Solver conflictsRestarts(long conflictsRestarts);
    public native @Cast("uint64_t") long nbstopsrestarts(); public native Solver nbstopsrestarts(long nbstopsrestarts);
    public native @Cast("uint64_t") long nbstopsrestartssame(); public native Solver nbstopsrestartssame(long nbstopsrestartssame);
    public native @Cast("uint64_t") long lastblockatrestart(); public native Solver lastblockatrestart(long lastblockatrestart);
    public native @Cast("uint64_t") long dec_vars(); public native Solver dec_vars(long dec_vars);
    public native @Cast("uint64_t") long clauses_literals(); public native Solver clauses_literals(long clauses_literals);
    public native @Cast("uint64_t") long learnts_literals(); public native Solver learnts_literals(long learnts_literals);
    public native @Cast("uint64_t") long max_literals(); public native Solver max_literals(long max_literals);
    public native @Cast("uint64_t") long tot_literals(); public native Solver tot_literals(long tot_literals);
    public native @ByRef LitVecPointer trail(); public native Solver trail(LitVecPointer trail);
}


//=================================================================================================
// Implementation of inline methods:
















// NOTE: enqueue does not set the ok flag! (only public methods do)






 






















// FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
// pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
// all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.















//=================================================================================================
// Debug etc:









//=================================================================================================





// #endif


// Parsed from simp/SimpSolver.h

/***************************************************************************************[SimpSolver.h]
 Glucose -- Copyright (c) 2009-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                LRI  - Univ. Paris Sud, France (2009-2013)
                                Labri - Univ. Bordeaux, France
 <p>
 Syrup (Glucose Parallel) -- Copyright (c) 2013-2014, Gilles Audemard, Laurent Simon
                                CRIL - Univ. Artois, France
                                Labri - Univ. Bordeaux, France
<p>
Glucose sources are based on MiniSat (see below MiniSat copyrights). Permissions and copyrights of
Glucose (sources until 2013, Glucose 3.0, single core) are exactly the same as Minisat on which it 
is based on. (see below).
<p>
Glucose-Syrup sources are based on another copyright. Permissions and copyrights for the parallel
version of Glucose-Syrup (the "Software") are granted, free of charge, to deal with the Software
without restriction, including the rights to use, copy, modify, merge, publish, distribute,
sublicence, and/or sell copies of the Software, and to permit persons to whom the Software is 
furnished to do so, subject to the following conditions:
<p>
- The above and below copyrights notices and this permission notice shall be included in all
copies or substantial portions of the Software;
- The parallel version of Glucose (all files modified since Glucose 3.0 releases, 2013) cannot
be used in any competitive event (sat competitions/evaluations) without the express permission of 
the authors (Gilles Audemard / Laurent Simon). This is also the case for any competitive event
using Glucose Parallel as an embedded SAT engine (single core or not).
<p>
<p>
--------------- Original Minisat Copyrights
<p>
Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/

// #ifndef Glucose_SimpSolver_h
// #define Glucose_SimpSolver_h

// #include "mtl/Queue.h"
// #include "core/Solver.h"
// #include "mtl/Clone.h"

//=================================================================================================


@Namespace("Glucose") @NoOffset public static class SimpSolver extends Solver {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SimpSolver(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public SimpSolver(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public SimpSolver position(long position) {
        return (SimpSolver)super.position(position);
    }

    // Constructor/Destructor:
    //
    public SimpSolver() { super((Pointer)null); allocate(); }
    private native void allocate();
    
    public SimpSolver(@Const @ByRef SimpSolver s) { super((Pointer)null); allocate(s); }
    private native void allocate(@Const @ByRef SimpSolver s);
    

    /**
     * Clone function
    */
    public native ClonePointer clone();   

    
    // Problem specification:
    //
    public native @Cast("Glucose::Var") int newVar(@Cast("bool") boolean polarity/*=true*/, @Cast("bool") boolean dvar/*=true*/);
    public native @Cast("Glucose::Var") int newVar(); // Add a new variable with parameters specifying variable mode.
    public native @Cast("bool") boolean addClause(@Const @ByRef LitVecPointer ps);
    public native @Cast("bool") boolean addEmptyClause();                // Add the empty clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p);               // Add a unit clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q);        // Add a binary clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r); // Add a ternary clause to the solver.
    public native @Cast("bool") boolean addClause_(      @ByRef LitVecPointer ps);
    public native @Cast("bool") boolean substitute(@Cast("Glucose::Var") int v, @ByVal Lit x);  // Replace all occurences of v with x (may cause a contradiction).

    // Variable mode:
    // 
    public native void setFrozen(@Cast("Glucose::Var") int v, @Cast("bool") boolean b); // If a variable is frozen it will not be eliminated.
    public native @Cast("bool") boolean isEliminated(@Cast("Glucose::Var") int v);

    // Solving:
    //
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps);
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps);
    public native @Cast("bool") boolean solve(                     @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve();
    public native @Cast("bool") boolean solve(@ByVal Lit p,        @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p);       
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q,        @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
    public native @Cast("bool") boolean eliminate(@Cast("bool") boolean turn_off_elim/*=false*/);
    public native @Cast("bool") boolean eliminate();  // Perform variable elimination based simplification. 

    // Memory managment:
    //
    public native void garbageCollect();


    // Generate a (possibly simplified) DIMACS file:
    //
// #if 0
// #endif

    // Mode of operation:
    //
    public native int parsing(); public native SimpSolver parsing(int parsing);
    public native int grow(); public native SimpSolver grow(int grow);              // Allow a variable elimination step to grow by a number of clauses (default to zero).
    public native int clause_lim(); public native SimpSolver clause_lim(int clause_lim);        // Variables are not eliminated if it produces a resolvent with a length above this limit.
                               // -1 means no limit.
    public native int subsumption_lim(); public native SimpSolver subsumption_lim(int subsumption_lim);   // Do not check if subsumption against a clause larger than this. -1 means no limit.
    public native double simp_garbage_frac(); public native SimpSolver simp_garbage_frac(double simp_garbage_frac); // A different limit for when to issue a GC during simplification (Also see 'garbage_frac').

    public native @Cast("bool") boolean use_asymm(); public native SimpSolver use_asymm(boolean use_asymm);         // Shrink clauses by asymmetric branching.
    public native @Cast("bool") boolean use_rcheck(); public native SimpSolver use_rcheck(boolean use_rcheck);        // Check if a clause is already implied. Prett costly, and subsumes subsumptions :)
    public native @Cast("bool") boolean use_elim(); public native SimpSolver use_elim(boolean use_elim);          // Perform variable elimination.
    // Statistics:
    //
    public native int merges(); public native SimpSolver merges(int merges);
    public native int asymm_lits(); public native SimpSolver asymm_lits(int asymm_lits);
    public native int eliminated_vars(); public native SimpSolver eliminated_vars(int eliminated_vars);
}


//=================================================================================================
// Implementation of inline methods:





















//=================================================================================================


// #endif


}
