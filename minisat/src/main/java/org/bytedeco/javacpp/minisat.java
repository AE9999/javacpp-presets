// Targeted by JavaCPP version 1.2: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class minisat extends org.bytedeco.javacpp.presets.minisat {
    static { Loader.load(); }

// Parsed from minisat/mtl/Alloc.h

/*****************************************************************************************[Alloc.h]
Copyright (c) 2008-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/


// #ifndef Minisat_Alloc_h
// #define Minisat_Alloc_h

// #include "minisat/mtl/XAlloc.h"
// #include "minisat/mtl/Vec.h"

//=================================================================================================
// Simple Region-based memory allocator:

@Name("Minisat::RegionAllocator<uint32_t>") @NoOffset public static class RegionAllocatorPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RegionAllocatorPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public RegionAllocatorPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public RegionAllocatorPointer position(long position) {
        return (RegionAllocatorPointer)super.position(position);
    }

    // TODO: make this a class for better type-checking?
    /** enum Minisat::RegionAllocator<uint32_t>:: */
    public static final int Ref_Undef = 0;
    /** enum Minisat::RegionAllocator<uint32_t>:: */
    
public static native @MemberGetter int Unit_Size();
public static final int Unit_Size = Unit_Size();

    public RegionAllocatorPointer(@Cast("uint32_t") int start_cap/*=1024*1024*/) { super((Pointer)null); allocate(start_cap); }
    private native void allocate(@Cast("uint32_t") int start_cap/*=1024*1024*/);
    public RegionAllocatorPointer() { super((Pointer)null); allocate(); }
    private native void allocate();


    public native @Cast("uint32_t") int size();
    public native @Cast("uint32_t") int wasted();

    public native @Cast("Minisat::RegionAllocator<uint32_t>::Ref") long alloc(int size); 
    public native void free(int size);

    // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    public native @Cast("uint32_t*") @ByRef @Name("operator []") IntPointer get(@Cast("Minisat::RegionAllocator<uint32_t>::Ref") long r);

    public native @Cast("uint32_t*") IntPointer lea(@Cast("Minisat::RegionAllocator<uint32_t>::Ref") long r);
    public native @Cast("Minisat::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") IntPointer t);
    public native @Cast("Minisat::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") IntBuffer t);
    public native @Cast("Minisat::RegionAllocator<uint32_t>::Ref") long ael(@Cast("const uint32_t*") int[] t);

    public native void moveTo(@ByRef RegionAllocatorPointer to);


}







//=================================================================================================


// #endif


// Parsed from minisat/mtl/Vec.h

/*******************************************************************************************[Vec.h]
Copyright (c) 2003-2007, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/

// #ifndef Minisat_Vec_h
// #define Minisat_Vec_h

// #include <assert.h>
// #include <limits>
// #include <new>

// #include "minisat/mtl/IntTypes.h"
// #include "minisat/mtl/XAlloc.h"

//=================================================================================================
// Automatically resizable arrays
//
// NOTE! Don't use this vector on datatypes that cannot be re-located in memory (with realloc)

@Name("Minisat::vec<Minisat::Var,int>") @NoOffset public static class VarVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VarVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VarVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public VarVecPointer position(long position) {
        return (VarVecPointer)super.position(position);
    }

    public native @Cast("Minisat::Var*") IntPointer data(); public native VarVecPointer data(IntPointer data);
    public native @Cast("Minisat::vec<Minisat::Var,int>::Size") int sz(); public native VarVecPointer sz(int sz);
    public native @Cast("Minisat::vec<Minisat::Var,int>::Size") int cap(); public native VarVecPointer cap(int cap);

    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") VarVecPointer put(@ByRef VarVecPointer other);
             public VarVecPointer(@ByRef VarVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef VarVecPointer other);

    public static native @Cast("Minisat::vec<Minisat::Var,int>::Size") int max(@Cast("Minisat::vec<Minisat::Var,int>::Size") int x, @Cast("Minisat::vec<Minisat::Var,int>::Size") int y);
    // Constructors:
    public VarVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public VarVecPointer(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size) { super((Pointer)null); allocate(size); }
    private native void allocate(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size);
    public VarVecPointer(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size, @Cast("const Minisat::Var") int pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size, @Cast("const Minisat::Var") int pad);

    // Pointer to first element:
    public native @Name("operator Minisat::Var*") IntPointer asIntPointer();

    // Size operations:
    public native @Cast("Minisat::vec<Minisat::Var,int>::Size") int size();
    public native void shrink(@Cast("Minisat::vec<Minisat::Var,int>::Size") int nelems);
    public native void shrink_(@Cast("Minisat::vec<Minisat::Var,int>::Size") int nelems);
    public native @Name("capacity") int _capacity();
    public native @Name("capacity") void _capacity(@Cast("Minisat::vec<Minisat::Var,int>::Size") int min_cap);
    public native void growTo(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size);
    public native void growTo(@Cast("Minisat::vec<Minisat::Var,int>::Size") int size, @Cast("const Minisat::Var") int pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    //void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    public native void push(@Cast("const Minisat::Var") int elem);
    public native void push_(@Cast("const Minisat::Var") int elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @Cast("Minisat::Var*") @ByRef IntPointer last();

    // Vector interface:
    public native @Cast("Minisat::Var*") @ByRef @Name("operator []") IntPointer get(@Cast("Minisat::vec<Minisat::Var,int>::Size") int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef VarVecPointer copy);
    public native void moveTo(@ByRef VarVecPointer dest);
}

@Name("Minisat::vec<Minisat::lbool,int>") @NoOffset public static class LboolVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LboolVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LboolVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public LboolVecPointer position(long position) {
        return (LboolVecPointer)super.position(position);
    }

    public native lbool data(); public native LboolVecPointer data(lbool data);
    public native @Cast("Minisat::vec<Minisat::lbool,int>::Size") int sz(); public native LboolVecPointer sz(int sz);
    public native @Cast("Minisat::vec<Minisat::lbool,int>::Size") int cap(); public native LboolVecPointer cap(int cap);

    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") LboolVecPointer put(@ByRef LboolVecPointer other);
             public LboolVecPointer(@ByRef LboolVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef LboolVecPointer other);

    public static native @Cast("Minisat::vec<Minisat::lbool,int>::Size") int max(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int x, @Cast("Minisat::vec<Minisat::lbool,int>::Size") int y);
    // Constructors:
    public LboolVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public LboolVecPointer(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size) { super((Pointer)null); allocate(size); }
    private native void allocate(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size);
    public LboolVecPointer(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size, @Const @ByRef lbool pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size, @Const @ByRef lbool pad);

    // Pointer to first element:
    public native @Name("operator Minisat::lbool*") lbool asLbool();

    // Size operations:
    public native @Cast("Minisat::vec<Minisat::lbool,int>::Size") int size();
    public native void shrink(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int nelems);
    public native void shrink_(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int nelems);
    public native @Name("capacity") int _capacity();
    public native @Name("capacity") void _capacity(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int min_cap);
    public native void growTo(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size);
    public native void growTo(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int size, @Const @ByRef lbool pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    //void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    public native void push(@Const @ByRef lbool elem);
    public native void push_(@Const @ByRef lbool elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @ByRef lbool last();

    // Vector interface:
    public native @ByRef @Name("operator []") lbool get(@Cast("Minisat::vec<Minisat::lbool,int>::Size") int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef LboolVecPointer copy);
    public native void moveTo(@ByRef LboolVecPointer dest);
}

@Name("Minisat::vec<Minisat::Lit,int>") @NoOffset public static class LitVecPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LitVecPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LitVecPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public LitVecPointer position(long position) {
        return (LitVecPointer)super.position(position);
    }

    public native Lit data(); public native LitVecPointer data(Lit data);
    public native @Cast("Minisat::vec<Minisat::Lit,int>::Size") int sz(); public native LitVecPointer sz(int sz);
    public native @Cast("Minisat::vec<Minisat::Lit,int>::Size") int cap(); public native LitVecPointer cap(int cap);

    // Don't allow copying (error prone):
    public native @ByRef @Name("operator =") LitVecPointer put(@ByRef LitVecPointer other);
             public LitVecPointer(@ByRef LitVecPointer other) { super((Pointer)null); allocate(other); }
             private native void allocate(@ByRef LitVecPointer other);

    public static native @Cast("Minisat::vec<Minisat::Lit,int>::Size") int max(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int x, @Cast("Minisat::vec<Minisat::Lit,int>::Size") int y);
    // Constructors:
    public LitVecPointer() { super((Pointer)null); allocate(); }
    private native void allocate();
    public LitVecPointer(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size) { super((Pointer)null); allocate(size); }
    private native void allocate(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size);
    public LitVecPointer(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size, @Const @ByRef Lit pad) { super((Pointer)null); allocate(size, pad); }
    private native void allocate(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size, @Const @ByRef Lit pad);

    // Pointer to first element:
    public native @Name("operator Minisat::Lit*") Lit asLit();

    // Size operations:
    public native @Cast("Minisat::vec<Minisat::Lit,int>::Size") int size();
    public native void shrink(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int nelems);
    public native void shrink_(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int nelems);
    public native @Name("capacity") int _capacity();
    public native @Name("capacity") void _capacity(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int min_cap);
    public native void growTo(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size);
    public native void growTo(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int size, @Const @ByRef Lit pad);
    public native void clear(@Cast("bool") boolean dealloc/*=false*/);
    public native void clear();

    // Stack interface:
    public native void push();
    //void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
    public native void push(@Const @ByRef Lit elem);
    public native void push_(@Const @ByRef Lit elem);
    public native void pop();
    // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
    // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
    // happen given the way capacities are calculated (below). Essentially, all capacities are
    // even, but INT_MAX is odd.
    public native @ByRef Lit last();

    // Vector interface:
    public native @ByRef @Name("operator []") Lit get(@Cast("Minisat::vec<Minisat::Lit,int>::Size") int index);

    // Duplicatation (preferred instead):
    public native void copyTo(@ByRef LitVecPointer copy);
    public native void moveTo(@ByRef LitVecPointer dest);
}













//=================================================================================================


// #endif


// Parsed from minisat/mtl/IntMap.h

/****************************************************************************************[IntMap.h]
Copyright (c) 2011, Niklas Sorensson
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/

// #ifndef Minisat_IntMap_h
// #define Minisat_IntMap_h

// #include "minisat/mtl/Vec.h"


    @Name("Minisat::IntSet<Minisat::Lit,Minisat::MkIndexLit>") public static class LitMkIndexLitSet extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public LitMkIndexLitSet() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public LitMkIndexLitSet(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public LitMkIndexLitSet(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public LitMkIndexLitSet position(long position) {
            return (LitMkIndexLitSet)super.position(position);
        }
    
        // Size operations:
        public native int size();
        public native void clear(@Cast("bool") boolean free/*=false*/);
        public native void clear();

        // Allow inspecting the internal vector:
        public native @Const @ByRef LitVecPointer toVec();
        
        // Vector interface:
        public native @ByVal @Name("operator []") Lit get(int index);
        
        
        public native void insert(@ByVal Lit k);
        public native @Cast("bool") boolean has(@ByVal Lit k);
    }

//     #if 0
//     #endif

//=================================================================================================
 // namespace Minisat
// #endif


// Parsed from minisat/core/SolverTypes.h

/***********************************************************************************[SolverTypes.h]
Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/


// #ifndef Minisat_SolverTypes_h
// #define Minisat_SolverTypes_h

// #include <assert.h>

// #include "minisat/mtl/IntTypes.h"
// #include "minisat/mtl/Alg.h"
// #include "minisat/mtl/Vec.h"
// #include "minisat/mtl/IntMap.h"
// #include "minisat/mtl/Map.h"
// #include "minisat/mtl/Alloc.h"

//=================================================================================================
// Variables, literals, lifted booleans, clauses:


// NOTE! Variables are just integers. No abstraction here. They should be chosen from 0..N,
// so that they can be used as array indices.
// #if defined(MINISAT_CONSTANTS_AS_MACROS)
public static final int var_Undef = (-1);
// #else
// #endif


@Namespace("Minisat") public static class Lit extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Lit() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Lit(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Lit(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Lit position(long position) {
        return (Lit)super.position(position);
    }

    public native int x(); public native Lit x(int x);

    // Use this as a constructor:
    

    public native @Cast("bool") @Name("operator ==") boolean equals(@ByVal Lit p);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@ByVal Lit p);
    public native @Cast("bool") @Name("operator <") boolean lessThan(@ByVal Lit p); // '<' makes p, ~p adjacent in the ordering.
}


@Namespace("Minisat") public static native @ByVal Lit mkLit(@Cast("Minisat::Var") int var, @Cast("bool") boolean sign);
@Namespace("Minisat") public static native @ByVal @Name("operator ~") Lit not(@ByVal Lit p);
@Namespace("Minisat") public static native @ByVal @Name("operator ^") Lit xor(@ByVal Lit p, @Cast("bool") boolean b);
@Namespace("Minisat") public static native @Cast("bool") boolean sign(@ByVal Lit p);
@Namespace("Minisat") public static native int var(@ByVal Lit p);

// Mapping Literals to and from compact integers suitable for array indexing:
@Namespace("Minisat") public static native int toInt(@Cast("Minisat::Var") int v); 
@Namespace("Minisat") public static native int toInt(@ByVal Lit p); 
@Namespace("Minisat") public static native @ByVal Lit toLit(int i); 

//const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
//const Lit lit_Error = mkLit(var_Undef, true );  // }

@Namespace("Minisat") @MemberGetter public static native @Const @ByRef Lit lit_Undef();  // }- Useful special constants.
@Namespace("Minisat") @MemberGetter public static native @Const @ByRef Lit lit_Error();  // }

@Namespace("Minisat") public static class MkIndexLit extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public MkIndexLit() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public MkIndexLit(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MkIndexLit(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public MkIndexLit position(long position) {
        return (MkIndexLit)super.position(position);
    }
 public native @Name("operator ()") int apply(@ByVal Lit l); }
@Namespace("Minisat") public static class LSet extends LitMkIndexLitSet {
    static { Loader.load(); }
    /** Default native constructor. */
    public LSet() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LSet(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LSet(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public LSet position(long position) {
        return (LSet)super.position(position);
    }
}

//=================================================================================================
// Lifted booleans:
//
// NOTE: this implementation is optimized for the case when comparisons between values are mostly
//       between one variable and one constant. Some care had to be taken to make sure that gcc 
//       does enough constant propagation to produce sensible code, and this appears to be somewhat
//       fragile unfortunately.

@Namespace("Minisat") @NoOffset public static class lbool extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public lbool(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public lbool(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public lbool position(long position) {
        return (lbool)super.position(position);
    }

    public lbool(@Cast("uint8_t") byte v) { super((Pointer)null); allocate(v); }
    private native void allocate(@Cast("uint8_t") byte v);

    public lbool() { super((Pointer)null); allocate(); }
    private native void allocate();
    public lbool(@Cast("bool") boolean x) { super((Pointer)null); allocate(x); }
    private native void allocate(@Cast("bool") boolean x);

    public native @Cast("bool") @Name("operator ==") boolean equals(@ByVal lbool b);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@ByVal lbool b);
    public native @ByVal @Name("operator ^") lbool xor(@Cast("bool") boolean b);

    public native @ByVal @Name("operator &&") lbool and(@ByVal lbool b);

    public native @ByVal @Name("operator ||") lbool or(@ByVal lbool b);

    
    
}
@Namespace("Minisat") public static native int toInt(@ByVal lbool l);
@Namespace("Minisat") public static native @ByVal lbool toLbool(int v);

// #if defined(MINISAT_CONSTANTS_AS_MACROS)
  public static native @MemberGetter @ByVal lbool l_True();
  public static final lbool l_True = l_True(); // gcc does not do constant propagation if these are real constants.
  public static native @MemberGetter @ByVal lbool l_False();
  public static final lbool l_False = l_False();
  public static native @MemberGetter @ByVal lbool l_Undef();
  public static final lbool l_Undef = l_Undef();
// #else
// #endif


//=================================================================================================
// Clause -- a simple class for representing a clause:

@Namespace("Minisat") public static class Clause extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Clause(Pointer p) { super(p); }

    public native void calcAbstraction();


    public native int size();
    public native void shrink(int i);
    public native void pop();
    public native @Cast("bool") boolean learnt();
    public native @Cast("bool") boolean has_extra();
    
    
    public native @Const @ByRef Lit last();

    public native @Cast("bool") boolean reloced();
    public native @Cast("Minisat::CRef") long relocation();
    public native void relocate(@Cast("Minisat::CRef") long c);

    // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
    //       subsumption operations to behave correctly.
    public native @ByRef @Name("operator []") Lit get(int i);
    public native @Const @Name("operator const Minisat::Lit*") Lit asLit();

    public native @ByRef FloatPointer activity();
    public native @Cast("uint32_t") int abstraction();

    public native @ByVal Lit subsumes(@Const @ByRef Clause other);
    public native void strengthen(@ByVal Lit p);
}


//=================================================================================================
// ClauseAllocator -- a simple class for allocating memory for clauses:

@Namespace("Minisat") @MemberGetter public static native @Cast("const Minisat::CRef") long CRef_Undef();
@Name("Minisat::ClauseAllocator") @NoOffset public static class ClauseAllocatorPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ClauseAllocatorPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ClauseAllocatorPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ClauseAllocatorPointer position(long position) {
        return (ClauseAllocatorPointer)super.position(position);
    }

    /** enum Minisat::ClauseAllocator:: */
    public static final int ClauseAllocatorUnitSize =RegionAllocatorPointer.Unit_Size;

    public native @Cast("bool") boolean extra_clause_field(); public native ClauseAllocatorPointer extra_clause_field(boolean extra_clause_field);

    public ClauseAllocatorPointer(@Cast("uint32_t") int start_cap) { super((Pointer)null); allocate(start_cap); }
    private native void allocate(@Cast("uint32_t") int start_cap);
    public ClauseAllocatorPointer() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native void moveTo(@ByRef ClauseAllocatorPointer to);

    public native @Cast("Minisat::CRef") long alloc(@Const @ByRef LitVecPointer ps, @Cast("bool") boolean learnt/*=false*/);
    public native @Cast("Minisat::CRef") long alloc(@Const @ByRef LitVecPointer ps);

    public native @Cast("Minisat::CRef") long alloc(@Const @ByRef Clause from);

    public native @Cast("uint32_t") int size();
    public native @Cast("uint32_t") int wasted();

    // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    public native @ByRef @Name("operator []") Clause get(@Cast("Minisat::CRef") long r);
    public native Clause lea(@Cast("Minisat::CRef") long r);
    public native @Cast("Minisat::CRef") long ael(@Const Clause t);

    public native void free(@Cast("Minisat::CRef") long cid);

    
}

//=================================================================================================
// Simple iterator classes (for iterating over clauses and top-level assignments):

@Namespace("Minisat") @NoOffset public static class ClauseIterator extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ClauseIterator(Pointer p) { super(p); }

    public ClauseIterator(@Const @ByRef ClauseAllocatorPointer _ca, @Cast("const Minisat::CRef*") long _crefs) { super((Pointer)null); allocate(_ca, _crefs); }
    private native void allocate(@Const @ByRef ClauseAllocatorPointer _ca, @Cast("const Minisat::CRef*") long _crefs);

    public native @Name("operator ++") void increment();
    public native @Const @ByRef @Name("operator *") Clause multiply();

    // NOTE: does not compare that references use the same clause-allocator:
    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef ClauseIterator ci);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef ClauseIterator ci);
}


@Namespace("Minisat") @NoOffset public static class TrailIterator extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TrailIterator(Pointer p) { super(p); }

    public TrailIterator(@Const Lit _lits) { super((Pointer)null); allocate(_lits); }
    private native void allocate(@Const Lit _lits);

    public native @Name("operator ++") void increment();
    public native @ByVal @Name("operator *") Lit multiply();

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef TrailIterator ti);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef TrailIterator ti);
}


//=================================================================================================
// OccLists -- a class for maintaining occurence lists with lazy deletion:








//=================================================================================================
// CMap -- a class for mapping clauses to values:


/*_________________________________________________________________________________________________
|
|  subsumes : (other : const Clause&)  ->  Lit
|  
|  Description:
|       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
|       by subsumption resolution.
|  
|    Result:
|       lit_Error  - No subsumption or simplification
|       lit_Undef  - Clause subsumes 'other'
|       p          - The literal p can be deleted from 'other'
|________________________________________________________________________________________________@*/




//=================================================================================================


// #endif


// Parsed from minisat/core/Solver.h

/****************************************************************************************[Solver.h]
Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/

// #ifndef Minisat_Solver_h
// #define Minisat_Solver_h

// #include "minisat/mtl/Vec.h"
// #include "minisat/mtl/Heap.h"
// #include "minisat/mtl/Alg.h"
// #include "minisat/mtl/IntMap.h"
// #include "minisat/utils/Options.h"
// #include "minisat/core/SolverTypes.h"

//=================================================================================================
// Solver -- the main class:

@Namespace("Minisat") @NoOffset public static class Solver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Solver(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Solver(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Solver position(long position) {
        return (Solver)super.position(position);
    }


    // Constructor/Destructor:
    //
    public Solver() { super((Pointer)null); allocate(); }
    private native void allocate();

    // Problem specification:
    //
    public native @Cast("Minisat::Var") int newVar(@ByVal(nullValue = "l_Undef") lbool upol/*=l_Undef*/, @Cast("bool") boolean dvar/*=true*/);
    public native @Cast("Minisat::Var") int newVar(); // Add a new variable with parameters specifying variable mode.
    public native void releaseVar(@ByVal Lit l);                                  // Make literal true and promise to never refer to variable again.

    public native @Cast("bool") boolean addClause(@Const @ByRef LitVecPointer ps);                     // Add a clause to the solver. 
    public native @Cast("bool") boolean addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
    public native @Cast("bool") boolean addClause(@ByVal Lit p);                                  // Add a unit clause to the solver. 
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q);                           // Add a binary clause to the solver. 
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);                    // Add a ternary clause to the solver. 
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r, @ByVal Lit s);             // Add a quaternary clause to the solver. 
    public native @Cast("bool") boolean addClause_(      @ByRef LitVecPointer ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                // change the passed vector 'ps'.

    // Solving:
    //
    public native @Cast("bool") boolean simplify();                        // Removes already satisfied clauses.
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps); // Search for a model that respects a given set of assumptions.
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps); // Search for a model that respects a given set of assumptions (With resource constraints).
    public native @Cast("bool") boolean solve();                        // Search without assumptions.
    public native @Cast("bool") boolean solve(@ByVal Lit p);                   // Search for a model that respects a single assumption.
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q);            // Search for a model that respects two assumptions.
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);     // Search for a model that respects three assumptions.
    public native @Cast("bool") boolean okay();                  // FALSE means solver is in a conflicting state

    public native @Cast("bool") boolean implies(@Const @ByRef LitVecPointer assumps, @ByRef LitVecPointer out);

    // Iterate over clauses and top-level assignments:
    public native @ByVal ClauseIterator clausesBegin();
    public native @ByVal ClauseIterator clausesEnd();
    public native @ByVal TrailIterator trailBegin();
    public native @ByVal TrailIterator trailEnd();

    public native void toDimacs(@Cast("FILE*") Pointer f, @Const @ByRef LitVecPointer assumps);            // Write CNF to file in DIMACS-format.
    public native void toDimacs(@Cast("const char*") BytePointer file, @Const @ByRef LitVecPointer assumps);
    public native void toDimacs(String file, @Const @ByRef LitVecPointer assumps);
    public native void toDimacs(@Cast("FILE*") Pointer f, @ByRef Clause c, @ByRef VarVecPointer map, @Cast("Minisat::Var*") @ByRef IntPointer max);
    public native void toDimacs(@Cast("FILE*") Pointer f, @ByRef Clause c, @ByRef VarVecPointer map, @Cast("Minisat::Var*") @ByRef IntBuffer max);
    public native void toDimacs(@Cast("FILE*") Pointer f, @ByRef Clause c, @ByRef VarVecPointer map, @Cast("Minisat::Var*") @ByRef int[] max);

    // Convenience versions of 'toDimacs()':
    public native void toDimacs(@Cast("const char*") BytePointer file);
    public native void toDimacs(String file);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p);
    public native void toDimacs(String file, @ByVal Lit p);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p, @ByVal Lit q);
    public native void toDimacs(String file, @ByVal Lit p, @ByVal Lit q);
    public native void toDimacs(@Cast("const char*") BytePointer file, @ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
    public native void toDimacs(String file, @ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
    
    // Variable mode:
    // 
    public native void setPolarity(@Cast("Minisat::Var") int v, @ByVal lbool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
    public native void setDecisionVar(@Cast("Minisat::Var") int v, @Cast("bool") boolean b);  // Declare if a variable should be eligible for selection in the decision heuristic.

    // Read state:
    //
    public native @ByVal lbool value(@Cast("Minisat::Var") int x);       // The current value of a variable.
    public native @ByVal lbool value(@ByVal Lit p);       // The current value of a literal.
    public native @ByVal lbool modelValue(@Cast("Minisat::Var") int x);       // The value of a variable in the last model. The last call to solve must have been satisfiable.
    public native @ByVal lbool modelValue(@ByVal Lit p);       // The value of a literal in the last model. The last call to solve must have been satisfiable.
    public native int nAssigns();       // The current number of assigned literals.
    public native int nClauses();       // The current number of original clauses.
    public native int nLearnts();       // The current number of learnt clauses.
    public native int nVars();       // The current number of variables.
    public native int nFreeVars();
    public native void printStats();       // Print some current statistics to standard output.

    // Resource contraints:
    //
    public native void setConfBudget(@Cast("int64_t") long x);
    public native void setPropBudget(@Cast("int64_t") long x);
    public native void budgetOff();
    public native void interrupt();          // Trigger a (potentially asynchronous) interruption of the solver.
    public native void clearInterrupt();     // Clear interrupt indicator flag.

    // Memory managment:
    //
    public native void garbageCollect();
    public native void checkGarbage(double gf);
    public native void checkGarbage();

    // Extra results: (read-only member variable)
    //
    public native @ByRef LboolVecPointer model(); public native Solver model(LboolVecPointer model);             // If problem is satisfiable, this vector contains the model (if any).
    public native @ByRef LSet conflict(); public native Solver conflict(LSet conflict);          // If problem is unsatisfiable (possibly under assumptions),
                                  // this vector represent the final conflict clause expressed in the assumptions.

    // Mode of operation:
    //
    public native int verbosity(); public native Solver verbosity(int verbosity);
    public native double var_decay(); public native Solver var_decay(double var_decay);
    public native double clause_decay(); public native Solver clause_decay(double clause_decay);
    public native double random_var_freq(); public native Solver random_var_freq(double random_var_freq);
    public native double random_seed(); public native Solver random_seed(double random_seed);
    public native @Cast("bool") boolean luby_restart(); public native Solver luby_restart(boolean luby_restart);
    public native int ccmin_mode(); public native Solver ccmin_mode(int ccmin_mode);         // Controls conflict clause minimization (0=none, 1=basic, 2=deep).
    public native int phase_saving(); public native Solver phase_saving(int phase_saving);       // Controls the level of phase saving (0=none, 1=limited, 2=full).
    public native @Cast("bool") boolean rnd_pol(); public native Solver rnd_pol(boolean rnd_pol);            // Use random polarities for branching heuristics.
    public native @Cast("bool") boolean rnd_init_act(); public native Solver rnd_init_act(boolean rnd_init_act);       // Initialize variable activities with a small random value.
    public native double garbage_frac(); public native Solver garbage_frac(double garbage_frac);       // The fraction of wasted memory allowed before a garbage collection is triggered.
    public native int min_learnts_lim(); public native Solver min_learnts_lim(int min_learnts_lim);    // Minimum number to set the learnts limit to.

    public native int restart_first(); public native Solver restart_first(int restart_first);      // The initial restart limit.                                                                (default 100)
    public native double restart_inc(); public native Solver restart_inc(double restart_inc);        // The factor with which the restart limit is multiplied in each restart.                    (default 1.5)
    public native double learntsize_factor(); public native Solver learntsize_factor(double learntsize_factor);  // The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 / 3)
    public native double learntsize_inc(); public native Solver learntsize_inc(double learntsize_inc);     // The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)

    public native int learntsize_adjust_start_confl(); public native Solver learntsize_adjust_start_confl(int learntsize_adjust_start_confl);
    public native double learntsize_adjust_inc(); public native Solver learntsize_adjust_inc(double learntsize_adjust_inc);

    // Statistics: (read-only member variable)
    //
    public native @Cast("uint64_t") long solves(); public native Solver solves(long solves);
    public native @Cast("uint64_t") long starts(); public native Solver starts(long starts);
    public native @Cast("uint64_t") long decisions(); public native Solver decisions(long decisions);
    public native @Cast("uint64_t") long rnd_decisions(); public native Solver rnd_decisions(long rnd_decisions);
    public native @Cast("uint64_t") long propagations(); public native Solver propagations(long propagations);
    public native @Cast("uint64_t") long conflicts(); public native Solver conflicts(long conflicts);
    public native @Cast("uint64_t") long dec_vars(); public native Solver dec_vars(long dec_vars);
    public native @Cast("uint64_t") long num_clauses(); public native Solver num_clauses(long num_clauses);
    public native @Cast("uint64_t") long num_learnts(); public native Solver num_learnts(long num_learnts);
    public native @Cast("uint64_t") long clauses_literals(); public native Solver clauses_literals(long clauses_literals);
    public native @Cast("uint64_t") long learnts_literals(); public native Solver learnts_literals(long learnts_literals);
    public native @Cast("uint64_t") long max_literals(); public native Solver max_literals(long max_literals);
    public native @Cast("uint64_t") long tot_literals(); public native Solver tot_literals(long tot_literals);
}


//=================================================================================================
// Implementation of inline methods:
















// NOTE: enqueue does not set the ok flag! (only public methods do)






















// TODO: nFreeVars() is not quite correct, try to calculate right instead of adapting it like below:










// FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
// pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
// all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.



















//=================================================================================================
// Debug etc:


//=================================================================================================


// #endif


// Parsed from minisat/simp/SimpSolver.h

/************************************************************************************[SimpSolver.h]
Copyright (c) 2006,      Niklas Een, Niklas Sorensson
Copyright (c) 2007-2010, Niklas Sorensson
<p>
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute,
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<p>
The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**************************************************************************************************/

// #ifndef Minisat_SimpSolver_h
// #define Minisat_SimpSolver_h

// #include "minisat/mtl/Queue.h"
// #include "minisat/core/Solver.h"

//=================================================================================================


@Namespace("Minisat") @NoOffset public static class SimpSolver extends Solver {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SimpSolver(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public SimpSolver(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public SimpSolver position(long position) {
        return (SimpSolver)super.position(position);
    }

    // Constructor/Destructor:
    //
    public SimpSolver() { super((Pointer)null); allocate(); }
    private native void allocate();

    // Problem specification:
    //
    public native @Cast("Minisat::Var") int newVar(@ByVal(nullValue = "l_Undef") lbool upol/*=l_Undef*/, @Cast("bool") boolean dvar/*=true*/);
    public native @Cast("Minisat::Var") int newVar();
    public native void releaseVar(@ByVal Lit l);
    public native @Cast("bool") boolean addClause(@Const @ByRef LitVecPointer ps);
    public native @Cast("bool") boolean addEmptyClause();                // Add the empty clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p);               // Add a unit clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q);        // Add a binary clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r); // Add a ternary clause to the solver.
    public native @Cast("bool") boolean addClause(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r, @ByVal Lit s); // Add a quaternary clause to the solver. 
    public native @Cast("bool") boolean addClause_(      @ByRef LitVecPointer ps);
    public native @Cast("bool") boolean substitute(@Cast("Minisat::Var") int v, @ByVal Lit x);  // Replace all occurences of v with x (may cause a contradiction).

    // Variable mode:
    // 
    public native void setFrozen(@Cast("Minisat::Var") int v, @Cast("bool") boolean b); // If a variable is frozen it will not be eliminated.
    public native @Cast("bool") boolean isEliminated(@Cast("Minisat::Var") int v);

    // Alternative freeze interface (may replace 'setFrozen()'):
    public native void freezeVar(@Cast("Minisat::Var") int v);         // Freeze one variable so it will not be eliminated.
    public native void thaw();              // Thaw all frozen variables.


    // Solving:
    //
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@Const @ByRef LitVecPointer assumps);
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @ByVal lbool solveLimited(@Const @ByRef LitVecPointer assumps);
    public native @Cast("bool") boolean solve(                     @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve();
    public native @Cast("bool") boolean solve(@ByVal Lit p,        @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p);       
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q,        @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r, @Cast("bool") boolean do_simp/*=true*/, @Cast("bool") boolean turn_off_simp/*=false*/);
    public native @Cast("bool") boolean solve(@ByVal Lit p, @ByVal Lit q, @ByVal Lit r);
    public native @Cast("bool") boolean eliminate(@Cast("bool") boolean turn_off_elim/*=false*/);
    public native @Cast("bool") boolean eliminate();  // Perform variable elimination based simplification. 

    // Memory managment:
    //
    public native void garbageCollect();


    // Generate a (possibly simplified) DIMACS file:
    //
// #if 0
// #endif

    // Mode of operation:
    //
    public native int grow(); public native SimpSolver grow(int grow);              // Allow a variable elimination step to grow by a number of clauses (default to zero).
    public native int clause_lim(); public native SimpSolver clause_lim(int clause_lim);        // Variables are not eliminated if it produces a resolvent with a length above this limit.
                               // -1 means no limit.
    public native int subsumption_lim(); public native SimpSolver subsumption_lim(int subsumption_lim);   // Do not check if subsumption against a clause larger than this. -1 means no limit.
    public native double simp_garbage_frac(); public native SimpSolver simp_garbage_frac(double simp_garbage_frac); // A different limit for when to issue a GC during simplification (Also see 'garbage_frac').

    public native @Cast("bool") boolean use_asymm(); public native SimpSolver use_asymm(boolean use_asymm);         // Shrink clauses by asymmetric branching.
    public native @Cast("bool") boolean use_rcheck(); public native SimpSolver use_rcheck(boolean use_rcheck);        // Check if a clause is already implied. Prett costly, and subsumes subsumptions :)
    public native @Cast("bool") boolean use_elim(); public native SimpSolver use_elim(boolean use_elim);          // Perform variable elimination.
    public native @Cast("bool") boolean extend_model(); public native SimpSolver extend_model(boolean extend_model);      // Flag to indicate whether the user needs to look at the full model.

    // Statistics:
    //
    public native int merges(); public native SimpSolver merges(int merges);
    public native int asymm_lits(); public native SimpSolver asymm_lits(int asymm_lits);
    public native int eliminated_vars(); public native SimpSolver eliminated_vars(int eliminated_vars);
}


//=================================================================================================
// Implementation of inline methods:


























//=================================================================================================


// #endif


}
